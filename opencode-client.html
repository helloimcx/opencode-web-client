<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Â§©Áøº‰∫ëÁîµËÑëAI Cowork</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a2e; color: #eee; }
        .container { max-width: 900px; margin: 0 auto; padding: 20px; min-height: 100vh; }
        header { text-align: center; padding: 15px 0; border-bottom: 1px solid #333; margin-bottom: 15px; }
        h1 { font-size: 1.5rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .status { display: flex; align-items: center; justify-content: center; gap: 8px; margin-top: 8px; font-size: 0.85rem; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #666; }
        .status-dot.online { background: #4ade80; box-shadow: 0 0 10px #4ade80; }
        .chat-container { background: #16162a; border-radius: 12px; padding: 15px; margin-bottom: 15px; min-height: 400px; max-height: 60vh; overflow-y: auto; }
        .message { margin-bottom: 12px; padding: 12px; border-radius: 10px; max-width: 85%; }
        .message.user { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); margin-left: auto; }
        .message.assistant { background: #2a2a4a; margin-right: auto; }
        .message.system { background: transparent; margin: 10px auto; text-align: center; font-size: 0.85rem; color: #888; }
        .message.error { background: #3a1a1a; border: 1px solid #ef4444; margin: 10px auto; }
        .message-header { display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 0.75rem; opacity: 0.7; }
        .message-content { white-space: pre-wrap; line-height: 1.5; font-size: 0.95rem; }
        .input-area { display: flex; gap: 10px; background: #16162a; padding: 12px; border-radius: 12px; }
        textarea { flex: 1; background: #2a2a4a; border: 1px solid #444; border-radius: 8px; color: #eee; padding: 10px; resize: none; height: 50px; font-family: inherit; }
        textarea:focus { outline: none; border-color: #667eea; }
        button { padding: 0 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer; }
        button:hover:not(:disabled) { transform: scale(1.02); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .loading { display: inline-block; width: 14px; height: 14px; border: 2px solid #fff; border-top-color: transparent; border-radius: 50%; animation: spin 0.8s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .settings-bar { display: flex; gap: 10px; align-items: center; background: #16162a; padding: 10px 15px; border-radius: 10px; margin-bottom: 15px; }
        .settings-bar label { font-size: 0.8rem; color: #888; }
        .settings-bar select { background: #2a2a4a; border: 1px solid #444; border-radius: 6px; color: #eee; padding: 6px 10px; }

        /* Processing indicator */
        .processing-indicator { background: #1a1a3e; border-radius: 10px; padding: 12px; margin-bottom: 12px; border-left: 3px solid #667eea; }
        .processing-header { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; font-size: 0.8rem; color: #888; }
        .processing-spinner { width: 12px; height: 12px; border: 2px solid #667eea; border-top-color: transparent; border-radius: 50%; animation: spin 0.8s linear infinite; }
        .processing-steps { font-size: 0.85rem; }
        .processing-step { display: flex; align-items: flex-start; gap: 8px; margin-bottom: 6px; opacity: 0.7; }
        .processing-step.active { opacity: 1; color: #4ade80; }
        .processing-step.completed { opacity: 0.5; text-decoration: line-through; }
        .step-icon { flex-shrink: 0; margin-top: 2px; }
        .step-text { flex: 1; }
        .step-detail { font-size: 0.75rem; color: #666; margin-top: 2px; }

        /* Reasoning block */
        .reasoning-block { background: #1a1a2e; border-radius: 8px; padding: 10px; margin: 8px 0; font-size: 0.85rem; border-left: 2px solid #667eea; }
        .reasoning-header { display: flex; align-items: center; gap: 6px; color: #888; font-size: 0.75rem; margin-bottom: 6px; cursor: pointer; }
        .reasoning-content { color: #aaa; line-height: 1.4; max-height: 200px; overflow-y: auto; }
        .reasoning-content.collapsed { display: none; }

        /* Tool call */
        .tool-call { background: #1a2a1a; border-radius: 8px; padding: 10px; margin: 8px 0; border-left: 2px solid #4ade80; }
        .tool-header { display: flex; align-items: center; gap: 6px; font-size: 0.8rem; color: #4ade80; margin-bottom: 4px; }
        .tool-name { font-family: monospace; background: #2a3a2a; padding: 2px 6px; border-radius: 4px; }
        .tool-result { font-size: 0.85rem; color: #ccc; max-height: 150px; overflow-y: auto; margin-top: 6px; }

        /* Stream text */
        .stream-text { animation: fadeIn 0.3s ease-in; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* AI text content */
        .ai-text-content { line-height: 1.5; }

        /* Pre tag styling */
        pre { background: #0a0a1a; padding: 8px; border-radius: 4px; overflow-x: auto; font-size: 0.8rem; margin: 4px 0; }
        strong { color: #888; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Â§©Áøº‰∫ëÁîµËÑëAI Cowork</h1>
            <div class="status">
                <span class="status-dot" id="statusDot"></span>
                <span id="statusText">ÂàùÂßãÂåñ‰∏≠...</span>
            </div>
        </header>

        <div class="settings-bar">
            <label>Server:</label>
            <input type="text" id="serverUrl" value="http://localhost:4096" style="width: 150px; background: #2a2a4a; border: 1px solid #444; border-radius: 6px; color: #eee; padding: 6px 10px;">
            <button id="connectBtn" style="padding: 6px 16px;">ËøûÊé•</button>
            <span style="flex:1;"></span>
            <label>Ê®°Âûã:</label>
            <select id="modelSelect" style="width: 200px;"></select>
            <button id="newSessionBtn" style="padding: 6px 16px; background: #444;">Êñ∞Âª∫‰ºöËØù</button>
        </div>

        <div class="chat-container" id="chatContainer">
            <div class="message system">ÁÇπÂáª"ËøûÊé•"ÊåâÈíÆËøûÊé•Âà∞ OpenCode ÊúçÂä°Âô®</div>
        </div>

        <div class="input-area">
            <textarea id="promptInput" placeholder="ËæìÂÖ•Êåá‰ª§... (Enter ÂèëÈÄÅ)" disabled></textarea>
            <button id="sendBtn" disabled>ÂèëÈÄÅ</button>
        </div>
    </div>

    <script type="module">
        import { createOpencodeClient } from "https://esm.sh/@opencode-ai/sdk@latest";

        let client = null;
        let currentSessionId = null;
        let isConnected = false;
        let isProcessing = false;
        let eventStream = null;
        let processingIndicator = null;
        let assistantMessageDiv = null;
        let currentReasoningDiv = null;

        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const chatContainer = document.getElementById('chatContainer');
        const promptInput = document.getElementById('promptInput');
        const sendBtn = document.getElementById('sendBtn');
        const serverUrlInput = document.getElementById('serverUrl');
        const connectBtn = document.getElementById('connectBtn');
        const newSessionBtn = document.getElementById('newSessionBtn');
        const modelSelect = document.getElementById('modelSelect');

        serverUrlInput.value = localStorage.getItem('opencode_serverUrl') || 'http://localhost:4096';

        async function connect() {
            try {
                setStatus('connecting');
                addSystemMessage('Ê≠£Âú®ËøûÊé•...');

                client = createOpencodeClient({
                    baseUrl: serverUrlInput.value
                });

                // Get providers config
                const configResult = await client.config.providers();
                console.log('[DEBUG] Config result:', configResult);

                const config = configResult.data || configResult;
                updateModelList(config);

                setStatus('online');
                isConnected = true;
                promptInput.disabled = false;
                sendBtn.disabled = !currentSessionId;
                connectBtn.textContent = 'Â∑≤ËøûÊé•';
                connectBtn.disabled = true;
                newSessionBtn.disabled = false;

                localStorage.setItem('opencode_serverUrl', serverUrlInput.value);

                // Subscribe to SSE events for real-time updates
                await subscribeToEvents();

                // Try to restore previous session
                const savedSessionId = localStorage.getItem('opencode_sessionId');
                if (savedSessionId) {
                    currentSessionId = savedSessionId;
                    addSystemMessage('Â∑≤ËøûÊé•ÔºåÊÅ¢Â§ç‰ºöËØù - ' + savedSessionId.slice(-8));
                    await loadMessages();
                } else {
                    addSystemMessage('Â∑≤ËøûÊé•ÔºåËØ∑Êñ∞Âª∫‰ºöËØù');
                }

            } catch (error) {
                console.error('[ERROR]', error);
                setStatus('offline');
                addSystemMessage('ËøûÊé•Â§±Ë¥•: ' + error.message);
            }
        }

        async function subscribeToEvents() {
            try {
                console.log('[DEBUG] Subscribing to SSE events...');
                const events = await client.event.subscribe();
                eventStream = events.stream;

                // Process events in background
                (async () => {
                    try {
                        for await (const event of eventStream) {
                            console.log('[EVENT]', event.type, event.properties || event.data);
                            handleEvent(event);
                        }
                    } catch (err) {
                        console.error('[SSE Error]', err);
                    }
                })();

            } catch (error) {
                console.error('[ERROR] Failed to subscribe to events:', error);
            }
        }

        function handleEvent(event) {
            // Log ALL events for debugging
            console.log('[EVENT RAW]', JSON.stringify(event));

            const eventType = event.type || event.event || event.eventType;
            const properties = event.properties || event.data || event;

            console.log('[EVENT]', eventType, properties);

            // Filter events for current session only
            if (properties.sessionID && properties.sessionID !== currentSessionId) {
                console.log('[SKIP] Not current session:', properties.sessionID, 'vs', currentSessionId);
                return;
            }

            switch (eventType) {
                case 'message.created':
                case 'messageCreate':
                case 'messageCreated':
                    console.log('[HANDLE] message.created');
                    handleMessageCreated(properties);
                    break;
                case 'message.updated':
                case 'messageUpdate':
                case 'messageUpdated':
                    console.log('[HANDLE] message.updated');
                    handleMessageUpdated(properties);
                    break;
                case 'message.part.updated':
                case 'messagePartUpdated':
                case 'part.updated':
                    console.log('[HANDLE] message.part.updated');
                    // The part data is nested under properties.part
                    handlePartUpdated(properties.part || properties);
                    break;
                case 'session.status':
                    console.log('[HANDLE] session.status:', properties.status);
                    if (properties.status?.type === 'busy') {
                        showProcessingIndicator();
                    } else if (properties.status?.type === 'idle') {
                        hideProcessingIndicator();
                    }
                    break;
                default:
                    console.log('[Unhandled Event Type]', eventType);
            }
        }

        function handleMessageCreated(msg) {
            if (msg.info?.role === 'assistant' && isProcessing) {
                // Create placeholder for assistant message
                if (!assistantMessageDiv) {
                    assistantMessageDiv = createAssistantMessage('');
                    chatContainer.appendChild(assistantMessageDiv);
                }
            }
        }

        function handleMessageUpdated(msg) {
            console.log('[DEBUG] Message updated:', msg);
            // Reload messages when a message is updated (but not during active processing)
            if (msg.info?.role === 'assistant' && !isProcessing) {
                loadMessages();
            }
        }

        function handlePartUpdated(part) {
            console.log('[DEBUG] Part updated:', part);

            // Filter for current session
            if (part.sessionID && part.sessionID !== currentSessionId) {
                return;
            }

            // Create assistant message container if needed
            if (!assistantMessageDiv) {
                assistantMessageDiv = createAssistantMessage('');
                chatContainer.appendChild(assistantMessageDiv);
            }

            const contentDiv = assistantMessageDiv.querySelector('.message-content');
            if (!contentDiv) return;

            const partId = part.id;
            const partType = part.type;

            console.log('[PART] Type:', partType, 'ID:', partId, 'Delta:', part.delta, 'Text:', part.text?.substring(0, 50));

            switch (partType) {
                        case 'text': {
                    // SSE sends cumulative text - find or create the text element for this part
                    const textContent = part.text || '';
                    if (textContent) {
                        // Use part ID to find the specific element for this part
                        let textDiv = contentDiv.querySelector(`.text-block[data-part-id="${partId}"]`);
                        if (!textDiv) {
                            textDiv = document.createElement('div');
                            textDiv.className = 'text-block stream-text';
                            textDiv.setAttribute('data-part-id', partId || 'unknown');
                            textDiv.style.whiteSpace = 'pre-wrap';
                            contentDiv.appendChild(textDiv);
                        }
                        // Only update if content is different and longer
                        if (textContent.length > textDiv.textContent.length) {
                            textDiv.textContent = textContent;
                            scrollToBottom();
                        }
                    }
                    break;
                }

                case 'reasoning': {
                    // SSE sends cumulative reasoning - find or create element for this part
                    let reasoningDiv = contentDiv.querySelector(`.reasoning-inline[data-part-id="${partId}"]`);
                    if (!reasoningDiv) {
                        reasoningDiv = document.createElement('div');
                        reasoningDiv.className = 'reasoning-inline';
                        reasoningDiv.setAttribute('data-part-id', partId || 'unknown');
                        reasoningDiv.style.color = '#888';
                        reasoningDiv.style.fontStyle = 'italic';
                        reasoningDiv.style.fontSize = '0.85rem';
                        reasoningDiv.style.marginBottom = '8px';
                        reasoningDiv.style.padding = '8px';
                        reasoningDiv.style.background = '#1a1a2e';
                        reasoningDiv.style.borderRadius = '4px';
                        reasoningDiv.style.whiteSpace = 'pre-wrap';
                        contentDiv.appendChild(reasoningDiv);
                    }
                    // Only update if content is longer
                    const reasoningText = part.text || '';
                    if (reasoningText.length > reasoningDiv.textContent.length) {
                        reasoningDiv.textContent = reasoningText;
                        scrollToBottom();
                    }
                    break;
                }

                case 'step-start':
                    showProcessingIndicator();
                    break;

                case 'step-finish':
                    hideProcessingIndicator();
                    break;

                case 'tool-call':
                case 'toolCall': {
                    // Find or create tool call element for this part
                    let toolDiv = contentDiv.querySelector(`.tool-inline[data-part-id="${partId}"]`);
                    if (!toolDiv) {
                        console.log('[TOOL CALL]', part);
                        const toolName = part.name || part.toolName || part.tool || 'unknown';
                        const toolArgs = part.arguments || part.args || {};
                        const toolResult = part.result || part.output;
                        toolDiv = document.createElement('div');
                        toolDiv.className = 'tool-inline';
                        toolDiv.setAttribute('data-part-id', partId || 'unknown');
                        toolDiv.style.color = '#4ade80';
                        toolDiv.style.fontSize = '0.85rem';
                        toolDiv.style.marginTop = '4px';
                        toolDiv.style.padding = '4px 8px';
                        toolDiv.style.background = '#1a2a1a';
                        toolDiv.style.borderRadius = '4px';
                        toolDiv.style.border = '1px solid #2a3a2a';

                        let toolText = `üîß ${toolName}`;
                        if (Object.keys(toolArgs).length > 0) {
                            toolText += `(${JSON.stringify(toolArgs).substring(0, 50)}...)`;
                        }
                        if (toolResult) {
                            toolText += ' ‚úì';
                        }
                        toolDiv.textContent = toolText;
                        contentDiv.appendChild(toolDiv);
                        scrollToBottom();
                    }
                    break;
                }

                default:
                    // Check if this looks like a tool call even if type doesn't match
                    if (part.name || part.toolName || part.tool || part.tool) {
                        console.log('[TOOL CALL - Unknown Type]', partType, part);
                        const toolName = part.name || part.toolName || part.tool || 'unknown';
                        const toolArgs = part.arguments || part.args || {};
                        const toolResult = part.result || part.output;
                        let toolDiv = contentDiv.querySelector(`.tool-inline[data-part-id="${partId || 'unknown'}"]`);
                        if (!toolDiv) {
                            toolDiv = document.createElement('div');
                            toolDiv.className = 'tool-inline';
                            toolDiv.setAttribute('data-part-id', partId || 'unknown');
                            toolDiv.style.color = '#4ade80';
                            toolDiv.style.fontSize = '0.85rem';
                            toolDiv.style.marginTop = '4px';
                            toolDiv.style.padding = '4px 8px';
                            toolDiv.style.background = '#1a2a1a';
                            toolDiv.style.borderRadius = '4px';
                            toolDiv.style.border = '1px solid #2a3a2a';

                            let toolText = `üîß ${toolName}`;
                            if (Object.keys(toolArgs).length > 0) {
                                toolText += `(${JSON.stringify(toolArgs).substring(0, 50)}...)`;
                            }
                            if (toolResult) {
                                toolText += ' ‚úì';
                            }
                            toolDiv.textContent = toolText;
                            contentDiv.appendChild(toolDiv);
                            scrollToBottom();
                        }
                    } else {
                        console.log('[Unknown Part Type]', partType, part);
                    }
                    break;
            }
        }

        function showProcessingIndicator() {
            if (processingIndicator) return;

            processingIndicator = document.createElement('div');
            processingIndicator.className = 'processing-indicator';
            processingIndicator.innerHTML = `
                <div class="processing-header">
                    <span class="processing-spinner"></span>
                    <span>AI Ê≠£Âú®Â§ÑÁêÜ...</span>
                </div>
                <div class="processing-steps" id="processingSteps"></div>
            `;
            chatContainer.appendChild(processingIndicator);
            scrollToBottom();
        }

        function hideProcessingIndicator() {
            if (processingIndicator) {
                processingIndicator.style.opacity = '0';
                processingIndicator.style.transition = 'opacity 0.3s';
                setTimeout(() => processingIndicator?.remove(), 300);
                processingIndicator = null;
            }
        }

        function updateProcessingStep(name, status, detail = '') {
            if (!processingIndicator) showProcessingIndicator();

            const stepsDiv = processingIndicator.querySelector('.processing-steps');
            let stepDiv = stepsDiv.querySelector('.processing-step');

            if (!stepDiv) {
                stepDiv = document.createElement('div');
                stepDiv.className = `processing-step ${status}`;
                stepDiv.innerHTML = `
                    <span class="step-icon">${status === 'active' ? '‚è≥' : '‚úì'}</span>
                    <div class="step-text">
                        <div>${escapeHtml(name)}</div>
                        ${detail ? `<div class="step-detail">${escapeHtml(detail)}</div>` : ''}
                    </div>
                `;
                stepsDiv.appendChild(stepDiv);
            } else {
                stepDiv.className = `processing-step ${status}`;
                const icon = stepDiv.querySelector('.step-icon');
                if (icon) icon.textContent = status === 'completed' ? '‚úì' : '‚è≥';
            }
            scrollToBottom();
        }

        function addProcessingStep(name, status = 'active', detail = '') {
            if (!processingIndicator) showProcessingIndicator();

            const stepsDiv = processingIndicator.querySelector('.processing-steps');
            const stepDiv = document.createElement('div');
            stepDiv.className = `processing-step ${status}`;
            stepDiv.innerHTML = `
                <span class="step-icon">${status === 'active' ? '‚è≥' : '‚úì'}</span>
                <div class="step-text">
                    <div>${escapeHtml(name)}</div>
                    ${detail ? `<div class="step-detail">${escapeHtml(detail)}</div>` : ''}
                </div>
            `;
            stepsDiv.appendChild(stepDiv);
            scrollToBottom();
        }

        function showToolCall(toolData) {
            if (!assistantMessageDiv) {
                assistantMessageDiv = createAssistantMessage('');
                chatContainer.appendChild(assistantMessageDiv);
            }

            const contentDiv = assistantMessageDiv.querySelector('.message-content');
            const toolName = toolData.name || toolData.toolName || toolData.tool || 'unknown';

            // Check if tool call already exists, update it instead of creating duplicate
            let toolDiv = contentDiv.querySelector(`.tool-call[data-tool="${escapeHtml(toolName)}"]`);

            if (!toolDiv) {
                toolDiv = document.createElement('div');
                toolDiv.className = 'tool-call';
                toolDiv.setAttribute('data-tool', toolName);

                // Insert in correct position: after reasoning, before text
                const reasoningBlock = contentDiv.querySelector('.reasoning-block');
                const textContent = contentDiv.querySelector('.ai-text-content');

                if (reasoningBlock && textContent) {
                    contentDiv.insertBefore(toolDiv, textContent);
                } else if (textContent) {
                    contentDiv.insertBefore(toolDiv, textContent);
                } else if (reasoningBlock) {
                    contentDiv.insertBefore(toolDiv, reasoningBlock.nextSibling);
                } else {
                    contentDiv.appendChild(toolDiv);
                }
            }

            // Build/update content
            const toolArgs = toolData.arguments || toolData.args || {};
            const toolResult = toolData.result || toolData.output;

            let html = `
                <div class="tool-header">
                    <span>üîß</span>
                    <span class="tool-name">${escapeHtml(toolName)}</span>
                </div>`;

            if (Object.keys(toolArgs).length > 0) {
                html += `<div class="tool-result"><strong>ÂèÇÊï∞:</strong> <pre>${escapeHtml(JSON.stringify(toolArgs, null, 2))}</pre></div>`;
            }

            if (toolResult !== undefined) {
                const resultStr = typeof toolResult === 'string' ? toolResult : JSON.stringify(toolResult, null, 2);
                html += `<div class="tool-result"><strong>ÁªìÊûú:</strong> <pre>${escapeHtml(resultStr.substring(0, 500))}${resultStr.length > 500 ? '...' : ''}</pre></div>`;
            }

            toolDiv.innerHTML = html;
            scrollToBottom();
        }

        function createAssistantMessage(content) {
            const msgDiv = document.createElement('div');
            msgDiv.className = 'message assistant';
            msgDiv.innerHTML = `
                <div class="message-header">
                    <span>AI</span>
                    <span>${new Date().toLocaleTimeString()}</span>
                </div>
                <div class="message-content">${escapeHtml(content)}</div>
            `;
            return msgDiv;
        }

        function updateModelList(config) {
            modelSelect.innerHTML = '';

            const models = [];
            const providers = config.providers || config.all || [];

            providers.forEach(p => {
                const providerID = p.providerID || p.id;
                const providerModels = p.models || {};
                Object.entries(providerModels).forEach(([modelId, modelInfo]) => {
                    models.push({
                        value: `${providerID}:${modelId}`,
                        label: `${providerID}:${modelId}`,
                        cost: modelInfo.cost?.input || 0
                    });
                });
            });

            models.sort((a, b) => a.cost - b.cost);

            models.forEach(m => {
                const option = document.createElement('option');
                option.value = m.value;
                option.textContent = m.cost === 0 ? `${m.label} (ÂÖçË¥π)` : m.label;
                modelSelect.appendChild(option);
            });

            const kimiModel = models.find(m => m.value.includes('kimi-k2.5-free'));
            if (kimiModel) {
                modelSelect.value = kimiModel.value;
            } else {
                const freeModel = models.find(m => m.cost === 0);
                if (freeModel) {
                    modelSelect.value = freeModel.value;
                }
            }
        }

        async function createSession() {
            try {
                addSystemMessage('Ê≠£Âú®ÂàõÂª∫‰ºöËØù...');

                const session = await client.session.create({
                    body: { title: 'Web Session ' + new Date().toLocaleTimeString() }
                });

                currentSessionId = session.data?.id || session.id;

                if (!currentSessionId) {
                    addSystemMessage('ÂàõÂª∫Â§±Ë¥•: Êú™ËÉΩËé∑Âèñ‰ºöËØù ID');
                    return;
                }

                localStorage.setItem('opencode_sessionId', currentSessionId);
                chatContainer.innerHTML = '';
                addSystemMessage('Â∑≤ÂàõÂª∫‰ºöËØù - ' + currentSessionId.slice(-8));
                sendBtn.disabled = false;

                await loadMessages();

            } catch (error) {
                console.error('[ERROR] Create session:', error);
                addSystemMessage('ÂàõÂª∫Â§±Ë¥•: ' + error.message);
            }
        }

        async function loadMessages() {
            if (!currentSessionId || !client) return;

            try {
                const messages = await client.session.messages({
                    path: { id: currentSessionId }
                });

                console.log('[DEBUG] Loading messages:', messages);

                chatContainer.innerHTML = '';
                if (messages.data && Array.isArray(messages.data)) {
                    messages.data.forEach(msg => {
                        const role = msg.info?.role || 'user';

                        // Skip system messages
                        if (role === 'system') return;

                        console.log('[LOAD MSG]', role, msg);

                        let hasContent = false;
                        let content = '';
                        let partsHtml = '';

                        // Process all parts in order (matching real-time display)
                        if (msg.parts && Array.isArray(msg.parts)) {
                            msg.parts.forEach(p => {
                                console.log('[LOAD PART]', p.type, p);

                                const partId = p.id || 'unknown';

                                switch (p.type) {
                                    case 'text':
                                        // Use text-block class like real-time display
                                        partsHtml += `<div class="text-block stream-text" style="white-space: pre-wrap;" data-part-id="${partId}">${escapeHtml(p.text || '')}</div>`;
                                        hasContent = true;
                                        break;

                                    case 'reasoning':
                                        // Use reasoning-inline style like real-time display
                                        partsHtml += `<div class="reasoning-inline" data-part-id="${partId}" style="color: #888; font-style: italic; font-size: 0.85rem; margin-bottom: 8px; padding: 8px; background: #1a1a2e; border-radius: 4px; white-space: pre-wrap;">${escapeHtml(p.text || p.content || '')}</div>`;
                                        hasContent = true;
                                        break;

                                    case 'tool-call':
                                    case 'toolCall':
                                    case 'tool':
                                        // Use tool-inline style like real-time display
                                        const toolName = p.name || p.toolName || p.tool || 'unknown';
                                        const toolArgs = p.arguments || p.args || {};
                                        let toolText = `üîß ${toolName}`;
                                        if (Object.keys(toolArgs).length > 0) {
                                            toolText += `(${JSON.stringify(toolArgs).substring(0, 50)}...)`;
                                        }
                                        if (p.result || p.output) {
                                            toolText += ' ‚úì';
                                        }
                                        partsHtml += `<div class="tool-inline" data-part-id="${partId}" style="color: #4ade80; font-size: 0.85rem; margin-top: 4px; padding: 4px 8px; background: #1a2a1a; border-radius: 4px; border: 1px solid #2a3a2a;">${escapeHtml(toolText)}</div>`;
                                        hasContent = true;
                                        break;

                                    case 'step-start':
                                    case 'step-finish':
                                        // Skip step markers in loaded messages
                                        break;

                                    default:
                                        console.log('[Unknown part type in load]', p.type, p);
                                        if (p.text) {
                                            partsHtml += `<div class="text-block stream-text" style="white-space: pre-wrap;" data-part-id="${partId}">${escapeHtml(p.text)}</div>`;
                                            hasContent = true;
                                        }
                                }
                            });
                        }

                        if (hasContent) {
                            addMessageWithParts(role, content, partsHtml, false);
                        }
                    });
                }
                scrollToBottom();
            } catch (error) {
                console.error('[ERROR] Load messages:', error);
            }
        }

        function createToolCallHtml(toolData) {
            const toolName = toolData.name || toolData.toolName || toolData.tool || 'unknown';
            const toolArgs = toolData.arguments || toolData.args || toolData.input || {};
            const toolResult = toolData.result || toolData.output;

            let html = `
                <div class="tool-call">
                    <div class="tool-header">
                        <span>üîß</span>
                        <span class="tool-name">${escapeHtml(toolName)}</span>
                    </div>`;

            if (Object.keys(toolArgs).length > 0) {
                html += `<div class="tool-result"><strong>ÂèÇÊï∞:</strong> <pre>${escapeHtml(JSON.stringify(toolArgs, null, 2))}</pre></div>`;
            }

            if (toolResult !== undefined) {
                const resultStr = typeof toolResult === 'string' ? toolResult : JSON.stringify(toolResult, null, 2);
                html += `<div class="tool-result"><strong>ÁªìÊûú:</strong> <pre>${escapeHtml(resultStr.substring(0, 500))}${resultStr.length > 500 ? '...' : ''}</pre></div>`;
            }

            html += '</div>';
            return html;
        }

        function addMessageWithParts(role, content, partsHtml, scroll = true) {
            const msgDiv = document.createElement('div');
            msgDiv.className = 'message ' + role;

            let contentHtml = '';
            if (content) {
                contentHtml = `<div class="stream-text">${escapeHtml(content)}</div>`;
            }

            msgDiv.innerHTML = `
                <div class="message-header">
                    <span>${role === 'user' ? 'Áî®Êà∑' : role === 'error' ? 'ÈîôËØØ' : 'AI'}</span>
                    <span>${new Date().toLocaleTimeString()}</span>
                </div>
                <div class="message-content">${contentHtml}${partsHtml}</div>
            `;
            chatContainer.appendChild(msgDiv);
            if (scroll) scrollToBottom();
        }

        async function sendPrompt() {
            const text = promptInput.value.trim();
            if (!text || !currentSessionId || isProcessing) return;

            isProcessing = true;
            sendBtn.disabled = true;
            sendBtn.innerHTML = '<span class="loading"></span>';

            // Reset state
            assistantMessageDiv = null;
            currentReasoningDiv = null;

            addMessage('user', text);
            promptInput.value = '';

            showProcessingIndicator();
            addProcessingStep('ÂèëÈÄÅÊ∂àÊÅØ...', 'active');

            try {
                const [providerID, modelID] = modelSelect.value.split(':');

                updateProcessingStep('ÂèëÈÄÅÊ∂àÊÅØ...', 'completed');
                addProcessingStep('AI ÊÄùËÄÉ‰∏≠...', 'active');

                // Use session.prompt - this returns the AI response directly
                const result = await client.session.prompt({
                    path: { id: currentSessionId },
                    body: {
                        model: { providerID, modelID },
                        parts: [{ type: 'text', text }]
                    }
                });

                console.log('[DEBUG] Prompt result:', result);

                updateProcessingStep('AI ÊÄùËÄÉ‰∏≠...', 'completed');
                hideProcessingIndicator();

                // Extract and display final response
                const messageObj = result.data || result;
                let responseText = '';

                if (messageObj.parts) {
                    responseText = messageObj.parts
                        .filter(p => p.type === 'text')
                        .map(p => p.text)
                        .join('\n');
                }

                if (responseText && !assistantMessageDiv) {
                    assistantMessageDiv = createAssistantMessage(responseText);
                    chatContainer.appendChild(assistantMessageDiv);
                }

                scrollToBottom();

            } catch (error) {
                console.error('[ERROR]', error);
                hideProcessingIndicator();
                addMessage('error', 'ÂèëÈÄÅÂ§±Ë¥•: ' + error.message, false);
            } finally {
                isProcessing = false;
                assistantMessageDiv = null;
                sendBtn.disabled = false;
                sendBtn.textContent = 'ÂèëÈÄÅ';
            }
        }

        function setStatus(status) {
            statusDot.className = 'status-dot ' + status;
            statusText.textContent = status === 'online' ? 'Âú®Á∫ø' : status === 'offline' ? 'Á¶ªÁ∫ø' : 'ËøûÊé•‰∏≠...';
        }

        function addMessage(role, content, scroll = true, parts = null) {
            const msgDiv = document.createElement('div');
            msgDiv.className = 'message ' + role;

            let partsHtml = '';
            if (parts) {
                // Render all parts with appropriate styling
                parts.forEach(p => {
                    switch (p.type) {
                        case 'text':
                            partsHtml += `<div class="stream-text">${escapeHtml(p.text)}</div>`;
                            break;
                        case 'reasoning':
                            partsHtml += `
                                <div class="reasoning-block">
                                    <div class="reasoning-header" onclick="this.nextElementSibling.classList.toggle('collapsed')">
                                        <span>üß†</span>
                                        <span>ÊÄùËÄÉËøáÁ®ã</span>
                                        <span style="margin-left: auto;">‚ñº</span>
                                    </div>
                                    <div class="reasoning-content">${escapeHtml(p.text || p.content || '')}</div>
                                </div>`;
                            break;
                        case 'step-start':
                        case 'step-finish':
                            // Skip steps in loaded messages
                            break;
                    }
                });
            } else {
                partsHtml = escapeHtml(content);
            }

            msgDiv.innerHTML = `
                <div class="message-header">
                    <span>${role === 'user' ? 'Áî®Êà∑' : role === 'error' ? 'ÈîôËØØ' : 'AI'}</span>
                    <span>${new Date().toLocaleTimeString()}</span>
                </div>
                <div class="message-content">${partsHtml}</div>
            `;
            chatContainer.appendChild(msgDiv);
            if (scroll) scrollToBottom();
        }

        function addSystemMessage(text) {
            const msgDiv = document.createElement('div');
            msgDiv.className = 'message system';
            msgDiv.textContent = text;
            chatContainer.appendChild(msgDiv);
            scrollToBottom();
        }

        function scrollToBottom() {
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        connectBtn.addEventListener('click', connect);
        sendBtn.addEventListener('click', sendPrompt);
        promptInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); sendPrompt(); }
        });
        newSessionBtn.addEventListener('click', createSession);

        if (localStorage.getItem('opencode_serverUrl')) connect();
    </script>
</body>
</html>
